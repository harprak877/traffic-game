<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Traffic Management Game Starter</title>
    <!-- We use p5.js to simplify canvas drawing and input handling for beginners -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js"></script>
</head>
<body>
<script>
// dynamic grid configuration
const gridSize = 30               // pixel size of each grid square
let cols = 20                     // initial columns
let rows = 15                     // initial rows
// Expansion and info panel configuration
const EXPAND_SECONDS = 30            // seconds between expansions
let expandInterval = EXPAND_SECONDS * 60  // frames between expansions (assuming 60 fps)
const MAX_SPAWN_POINTS = 10         // cap for spawn/exit arrays
let lastRotationTime = 0            // for debouncing right-click rotation
let lastExpandTime = 0              // for debouncing expansion
const INFO_PANEL_HEIGHT = 60        // height of info panel
let expandTimer = 0                // counts frames for expansion

// data structures
let roadGrid = []      // holds placed road tiles or null
let cars = []          // list of car objects currently on map
let spawnPoints = []   // entry locations where cars appear
let exitPoints = []    // exit locations where cars aim to reach
let congestionGrid = [] // holds congestion counts per cell

// traffic control variables
let spawnTimer = 0      // counts frames between spawns
let spawnInterval = 120 // frames per new car, decreases over time

// user selection state
let selectedRoadType = 'straight'  // current road piece chosen by player

// scoring and effects
let score = 0
let lastScoreUpdate = 0
let dayNightCycle = 0
let rainParticles = []
let weatherIntensity = 0

function setup() {
    let cnv = createCanvas(gridSize * cols, gridSize * rows)
    // disable default context menu to allow right-click rotation
    cnv.elt.oncontextmenu = () => false
    initGrid()          // initialize empty grid and congestion
    initCongestionGrid()
    initSpawnAndExit()  // set up example entry and exit
}

// initialize grid as null values
function initGrid() {
    roadGrid = []
    for (let i = 0; i < cols; i++) {
        roadGrid[i] = []
        for (let j = 0; j < rows; j++) {
            roadGrid[i][j] = null
        }
    }
}

// initialize congestion grid counts
function initCongestionGrid() {
    congestionGrid = []
    for (let i = 0; i < cols; i++) {
        congestionGrid[i] = []
        for (let j = 0; j < rows; j++) {
            congestionGrid[i][j] = 0
        }
    }
}

// Generate randomized spawn/exit points with auto-generated connecting path
// Using plain integer objects instead of createVector to avoid float index issues
function initSpawnAndExit() {
    // Choose random edges for spawn and exit (opposite edges)
    let edges = ['top', 'bottom', 'left', 'right']
    let spawnEdge = random(edges)
    let exitEdge = getOppositeEdge(spawnEdge)
    
    // Generate spawn and exit points on chosen edges
    let spawn = getRandomPointOnEdge(spawnEdge)
    let exit = getRandomPointOnEdge(exitEdge)
    
    spawnPoints = [spawn]
    exitPoints = [exit]
    
    // Auto-generate a path between spawn and exit
    generateStarterPath(spawn, exit)
}

function getOppositeEdge(edge) {
    switch(edge) {
        case 'top': return 'bottom'
        case 'bottom': return 'top'
        case 'left': return 'right'
        case 'right': return 'left'
    }
}

function getRandomPointOnEdge(edge) {
    switch(edge) {
        case 'top': return {x: floor(random(1, cols-1)), y: 0}
        case 'bottom': return {x: floor(random(1, cols-1)), y: rows-1}
        case 'left': return {x: 0, y: floor(random(1, rows-1))}
        case 'right': return {x: cols-1, y: floor(random(1, rows-1))}
    }
}

function generateStarterPath(spawn, exit) {
    // Simple path generation - straight line with corners as needed
    let current = {x: spawn.x, y: spawn.y}
    let path = [current]
    
    // First, move towards exit horizontally
    while (current.x !== exit.x) {
        if (current.x < exit.x) {
            current = {x: current.x + 1, y: current.y}
        } else {
            current = {x: current.x - 1, y: current.y}
        }
        path.push({...current})
    }
    
    // Then move vertically
    while (current.y !== exit.y) {
        if (current.y < exit.y) {
            current = {x: current.x, y: current.y + 1}
        } else {
            current = {x: current.x, y: current.y - 1}
        }
        path.push({...current})
    }
    
    // Place road tiles along the path
    for (let i = 0; i < path.length; i++) {
        let point = path[i]
        let tileType = 'straight'
        let rotation = 0
        
        if (i === 0) {
            // First tile - determine direction
            if (i + 1 < path.length) {
                let next = path[i + 1]
                if (next.x > point.x) rotation = 0      // East
                else if (next.x < point.x) rotation = 180  // West
                else if (next.y > point.y) rotation = 90   // South
                else rotation = 270                        // North
            }
        } else if (i === path.length - 1) {
            // Last tile - determine from previous
            let prev = path[i - 1]
            if (prev.x < point.x) rotation = 0      // From West
            else if (prev.x > point.x) rotation = 180  // From East
            else if (prev.y < point.y) rotation = 90   // From North
            else rotation = 270                        // From South
        } else {
            // Middle tile - check if it's a corner
            let prev = path[i - 1]
            let next = path[i + 1]
            
            let prevDir = {x: point.x - prev.x, y: point.y - prev.y}
            let nextDir = {x: next.x - point.x, y: next.y - point.y}
            
            // If direction changes, it's a corner
            if (prevDir.x !== nextDir.x || prevDir.y !== nextDir.y) {
                tileType = 'corner'
                // Determine corner rotation based on directions
                if (prevDir.x === 1 && nextDir.y === 1) rotation = 0      // East to South
                else if (prevDir.y === 1 && nextDir.x === -1) rotation = 90   // South to West
                else if (prevDir.x === -1 && nextDir.y === -1) rotation = 180  // West to North
                else if (prevDir.y === -1 && nextDir.x === 1) rotation = 270   // North to East
                else if (prevDir.x === -1 && nextDir.y === 1) rotation = 0     // West to South
                else if (prevDir.y === -1 && nextDir.x === -1) rotation = 90   // North to West
                else if (prevDir.x === 1 && nextDir.y === -1) rotation = 180   // East to North
                else if (prevDir.y === 1 && nextDir.x === 1) rotation = 270    // South to East
            } else {
                // Straight tile
                if (prevDir.x !== 0) rotation = 0    // Horizontal
                else rotation = 90                   // Vertical
            }
        }
        
        roadGrid[point.x][point.y] = new RoadTile(point.x, point.y, tileType, rotation)
    }
}

function draw() {
    // Day-night cycle and weather
    updateDayNightCycle()
    updateWeather()
    
    drawTexturedBackground()
    drawGrid()                   // show grid lines
    handleTraffic()              // spawn cars and update movement
    resetCongestion()            // clear counts and recount each frame
    drawRoads()                  // draw road tiles with congestion glow
    drawCars()                   // render each car on top
    drawWeatherEffects()         // rain/fog effects
    drawGhostPreview()           // show preview of selected tile
    updateScore()                // calculate and update score
    showSelectionInfo()          // display which road piece is selected
    showScore()                  // display current score

    // expand map over time with debounce
    expandTimer++
    if (expandTimer >= expandInterval && millis() - lastExpandTime > 1000) {
        expandMap()
        expandTimer = 0
        lastExpandTime = millis()
    }
}

function updateDayNightCycle() {
    dayNightCycle = sin(frameCount / 300) // Slow cycle
    let dayColor = color(120, 160, 120)
    let nightColor = color(40, 60, 80)
    let currentBg = lerpColor(dayColor, nightColor, (dayNightCycle + 1) / 2)
    background(currentBg)
}

function updateWeather() {
    // Random weather changes
    if (frameCount % 600 === 0) { // Every 10 seconds
        weatherIntensity = random(0, 1)
    }
    
    // Add rain particles
    if (weatherIntensity > 0.3) {
        for (let i = 0; i < weatherIntensity * 5; i++) {
            rainParticles.push({
                x: random(width),
                y: -10,
                speed: random(3, 8)
            })
        }
    }
    
    // Update rain particles
    for (let i = rainParticles.length - 1; i >= 0; i--) {
        rainParticles[i].y += rainParticles[i].speed
        if (rainParticles[i].y > height) {
            rainParticles.splice(i, 1)
        }
    }
}

function drawWeatherEffects() {
    if (weatherIntensity > 0.3) {
        // Draw rain
        stroke(150, 150, 255, 150)
        strokeWeight(1)
        for (let particle of rainParticles) {
            line(particle.x, particle.y, particle.x - 2, particle.y - 8)
        }
        
        // Draw fog overlay
        if (weatherIntensity > 0.6) {
            fill(200, 200, 255, 30)
            noStroke()
            rect(0, 0, width, height)
        }
    }
}

// draw textured grass background
function drawTexturedBackground() {
    // Add subtle noise texture to grass
    for (let i = 0; i < width; i += 4) {
        for (let j = 0; j < height; j += 4) {
            let variation = noise(i * 0.01, j * 0.01) * 30
            let baseGreen = 120 + (dayNightCycle * 30) // Darker at night
            fill(baseGreen + variation, 160 + variation, baseGreen + variation, 50)
            noStroke()
            rect(i, j, 4, 4)
        }
    }
}

// draw grid lines
function drawGrid() {
    stroke(140, 180, 140, 100)  // Subtle grid lines
    strokeWeight(1)
    for (let i = 0; i <= cols; i++) {
        line(i * gridSize, 0, i * gridSize, height)
    }
    for (let j = 0; j <= rows; j++) {
        line(0, j * gridSize, width, j * gridSize)
    }
}

// expand grid by one column and one row
function expandMap() {
    cols++
    rows++
    // Note: resizeCanvas triggers a redraw next frame. If you need to reference
    // width/height immediately after this call (same call stack), be aware that
    // p5 may not have updated them yet.
    resizeCanvas(gridSize * cols, gridSize * rows)
    // extend each existing row
    for (let i = 0; i < cols; i++) {
        if (!roadGrid[i]) {
            roadGrid[i] = Array(rows).fill(null)
            congestionGrid[i] = Array(rows).fill(0)
        } else {
            roadGrid[i].push(null)
            congestionGrid[i].push(0)
        }
    }
    // add new column
    if (roadGrid.length < cols) {
        roadGrid.push(Array(rows).fill(null))
        congestionGrid.push(Array(rows).fill(0))
    }
    // adjust spawn/exit on new edges
    spawnPoints.push({x: 0, y: rows - 1})
    exitPoints.push({x: cols - 1, y: 0})
    // prune old spawn/exit entries
    // Note: Pruning removes oldest entries regardless of road connectivity.
    // In very long games, this could remove spawn/exit points that are still
    // reachable by roads, potentially affecting pathfinding.
    if (spawnPoints.length > MAX_SPAWN_POINTS) spawnPoints.shift()
    if (exitPoints.length  > MAX_SPAWN_POINTS) exitPoints.shift()
    // increase traffic further upon expansion
    if (spawnInterval > 20) spawnInterval -= 10
}

// reset congestion counts
function resetCongestion() {
    for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
            congestionGrid[i][j] = 0
        }
    }
    // count cars per cell
    for (let c of cars) {
        let ci = floor(c.pos.x / gridSize)
        let cj = floor(c.pos.y / gridSize)
        if (ci >= 0 && ci < cols && cj >= 0 && cj < rows) {
            congestionGrid[ci][cj]++
        }
    }
}

// class and helper functions remain unchanged
class RoadTile {
    constructor(x, y, type, rotation) {
        this.x = x; this.y = y
        this.type = type
        this.rotation = rotation
        this.connections = getConnections(type, rotation)
    }
}

function getConnections(type, rotation) {
    const base = {
        straight: [[1,0],[-1,0]],
        corner:   [[1,0],[0,1]],
        t_junction:[[0,-1],[1,0],[0,1]],
        cross:    [[1,0],[-1,0],[0,-1],[0,1]],
        roundabout:[[1,0],[0,1],[-1,0],[0,-1]],
        flyover:  [[1,0],[-1,0]]
    }
    if (!base[type]) return []
    let dirs = base[type].map(d => d.slice())
    let times = (rotation / 90) % 4
    for (let k = 0; k < times; k++) dirs = dirs.map(d => [d[1],-d[0]])
    return dirs
}

function drawRoads() {
    // Lazy rendering - only draw tiles within view bounds (with small buffer)
    let minI = max(0, floor(-gridSize / gridSize))
    let maxI = min(cols, ceil((width + gridSize) / gridSize))
    let minJ = max(0, floor(-gridSize / gridSize))
    let maxJ = min(rows, ceil((height + gridSize) / gridSize))
    
    for (let i = minI; i < maxI; i++)
    for (let j = minJ; j < maxJ; j++) {
        const tile = roadGrid[i]?.[j]
        if (!tile) continue
        
        // Draw gradient congestion glow
        let carCount = congestionGrid[i][j]
        if (carCount > 0) {
            let congestionColor
            if (carCount <= 2) {
                congestionColor = lerpColor(color(0,255,0,80), color(255,255,0,100), carCount/2)
            } else {
                congestionColor = lerpColor(color(255,255,0,100), color(255,0,0,120), min((carCount-2)/3, 1))
            }
            noStroke(); fill(congestionColor)
            rect(i*gridSize,j*gridSize,gridSize,gridSize)
        }
        
        push(); translate(i*gridSize+gridSize/2, j*gridSize+gridSize/2)
        rotate(radians(tile.rotation)); drawTileShape(tile.type, tile); pop()
        
        // Draw traffic flow arrows
        drawTrafficArrows(i, j, tile)
    }
}

function drawTileShape(type, tile) {
    // Enhanced road colors - darker asphalt look
    let roadColor = color(60, 60, 60)
    let shadowColor = color(40, 40, 40)
    
    // Draw shadow first (offset slightly)
    push()
    translate(2, 2)
    noStroke(); fill(shadowColor)
    drawShapeGeometry(type)
    pop()
    
    // Draw main road
    noStroke(); fill(roadColor)
    drawShapeGeometry(type)
    
    // Add lane markings
    stroke(200, 200, 0); strokeWeight(1)
    drawLaneMarkings(type)
    
    // Special coloring for spawn/exit points
    if (isSpawnPoint(tile)) {
        fill(0, 255, 0, 100)  // Green overlay for spawn
        drawShapeGeometry(type)
    } else if (isExitPoint(tile)) {
        fill(0, 100, 255, 100)  // Blue overlay for exit
        drawShapeGeometry(type)
    }
}

function drawShapeGeometry(type) {
    switch(type) {
        case 'straight': 
            // Rounded ends for straight roads
            rect(-gridSize/6,-gridSize/2,gridSize/3,gridSize, 4); 
            break
        case 'corner': 
            // Smooth bezier corner
            beginShape()
            vertex(-gridSize/6, 0)
            bezierVertex(-gridSize/6, -gridSize/4, -gridSize/4, -gridSize/6, 0, -gridSize/6)
            vertex(gridSize/2, -gridSize/6)
            vertex(gridSize/2, gridSize/6)
            bezierVertex(gridSize/4, gridSize/6, gridSize/6, gridSize/4, gridSize/6, 0)
            vertex(gridSize/6, gridSize/2)
            vertex(-gridSize/6, gridSize/2)
            endShape(CLOSE)
            break
        case 't_junction': 
            rect(-gridSize/6,-gridSize/2,gridSize/3,gridSize, 4); 
            rect(-gridSize/2,-gridSize/6,gridSize,gridSize/3, 4); 
            break
        case 'cross': 
            rect(-gridSize/6,-gridSize/2,gridSize/3,gridSize, 4); 
            rect(-gridSize/2,-gridSize/6,gridSize,gridSize/3, 4); 
            break
        case 'roundabout': 
            ellipse(0,0,gridSize*0.8,gridSize*0.8); 
            break
        case 'flyover': 
            rect(-gridSize/6,-gridSize/2,gridSize/3,gridSize, 4); 
            rect(-gridSize/2,-gridSize/6,gridSize,gridSize/3, 4); 
            break
    }
}

function drawLaneMarkings(type) {
    switch(type) {
        case 'straight':
            line(0, -gridSize/2, 0, gridSize/2)
            break
        case 't_junction':
            line(0, -gridSize/2, 0, gridSize/2)
            line(-gridSize/2, 0, gridSize/2, 0)
            break
        case 'cross':
            line(0, -gridSize/2, 0, gridSize/2)
            line(-gridSize/2, 0, gridSize/2, 0)
            break
    }
}

function handleTraffic() {
    spawnTimer++
    if (spawnTimer > spawnInterval) {
        spawnCar(); spawnTimer = 0
        if (spawnInterval > 30) spawnInterval--
    }
    cars.forEach(c => c.update())
    // remove cars that have reached their destination or are stuck
    cars = cars.filter(c => c.currentIndex < c.path.length - 1 && !c.isStuck())
}

function spawnCar() {
    const start = random(spawnPoints)
    const end   = random(exitPoints)
    const path  = findPath(start,end)
    if (path) cars.push(new Car(path))
}

function findPath(start,end) {/* BFS unchanged */
    const visited = Array(cols).fill().map(()=>Array(rows).fill(false))
    const prev    = Array(cols).fill().map(()=>Array(rows).fill(null))
    const queue = [{x:start.x,y:start.y}]
    visited[start.x][start.y]=true
    while(queue.length){
        const cell=queue.shift()
        if(cell.x==end.x&&cell.y==end.y) break
        const tile=roadGrid[cell.x][cell.y]
        if(!tile) continue
        tile.connections.forEach(dir=>{
            const nx=cell.x+dir[0], ny=cell.y+dir[1]
            if(nx>=0&&nx<cols&&ny>=0&&ny<rows&&!visited[nx][ny]){
                const nb=roadGrid[nx][ny]
                if(nb&&nb.connections.some(d=>d[0]==-dir[0]&&d[1]==-dir[1])){
                    visited[nx][ny]=true; prev[nx][ny]=cell; queue.push({x:nx,y:ny})
                }
            }
        })
    }
    if(!visited[end.x][end.y]) return null
    const path=[]; let cur={x:end.x,y:end.y}
    while(cur){path.push(cur);cur=prev[cur.x][cur.y]}
    return path.reverse()
}

class Car {
    constructor(path){
        this.path=path;
        this.currentIndex=0;
        this.pos=createVector(path[0].x*gridSize+gridSize/2,path[0].y*gridSize+gridSize/2);
        this.speed=1;
        this.lastProgressTime = millis(); // track when car last advanced
        this.stuckThreshold = 5000; // 5 seconds in milliseconds
    }
    update(){
        if(this.currentIndex<this.path.length-1){
            const tgt=this.path[this.currentIndex+1]
            const tpos=createVector(tgt.x*gridSize+gridSize/2,tgt.y*gridSize+gridSize/2)
            const dir=p5.Vector.sub(tpos,this.pos)
            if(dir.mag()>this.speed){
                dir.normalize().mult(this.speed);
                this.pos.add(dir)
            } else {
                this.pos=tpos.copy();
                this.currentIndex++;
                this.lastProgressTime = millis(); // reset timer when advancing
            }
        }
    }
    isStuck(){
        return millis() - this.lastProgressTime > this.stuckThreshold;
    }
    show(){noStroke();fill(255,0,0);ellipse(this.pos.x,this.pos.y,gridSize/2)}
}

function drawCars(){cars.forEach(c=>c.show())}

function drawTrafficArrows(i, j, tile) {
    if (!tile.connections) return
    
    push()
    translate(i*gridSize+gridSize/2, j*gridSize+gridSize/2)
    stroke(150, 150, 0, 150)
    strokeWeight(2)
    
    tile.connections.forEach(dir => {
        let angle = atan2(dir[1], dir[0])
        push()
        rotate(angle)
        translate(gridSize/4, 0)
        line(-3, -3, 0, 0)
        line(-3, 3, 0, 0)
        pop()
    })
    pop()
}

function drawGhostPreview() {
    if (mouseX >= 0 && mouseX < width && mouseY >= 0 && mouseY < height) {
        let i = floor(mouseX / gridSize)
        let j = floor(mouseY / gridSize)
        
        if (i >= 0 && i < cols && j >= 0 && j < rows) {
            // Show hover highlight
            if (roadGrid[i][j]) {
                // Invalid placement - red overlay
                fill(255, 0, 0, 100)
                noStroke()
                rect(i*gridSize, j*gridSize, gridSize, gridSize)
            } else {
                // Valid placement - show ghost preview
                fill(255, 255, 255, 50)
                stroke(255, 255, 255, 100)
                strokeWeight(2)
                rect(i*gridSize, j*gridSize, gridSize, gridSize)
                
                // Draw ghost tile
                push()
                translate(i*gridSize+gridSize/2, j*gridSize+gridSize/2)
                fill(255, 255, 255, 80)
                noStroke()
                drawShapeGeometry(selectedRoadType)
                pop()
            }
        }
    }
}

function isSpawnPoint(tile) {
    if (!tile) return false
    return spawnPoints.some(sp => sp.x === tile.x && sp.y === tile.y)
}

function isExitPoint(tile) {
    if (!tile) return false
    return exitPoints.some(ep => ep.x === tile.x && ep.y === tile.y)
}

function updateScore() {
    if (millis() - lastScoreUpdate > 1000) { // Update every second
        let totalCongestion = 0
        let totalCars = cars.length
        
        // Calculate congestion penalty
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                if (congestionGrid[i][j] > 2) {
                    totalCongestion += congestionGrid[i][j] - 2
                }
            }
        }
        
        // Score increases for smooth traffic, decreases for congestion
        let scoreChange = totalCars * 10 - totalCongestion * 5
        score += scoreChange
        score = max(0, score) // Don't go below 0
        
        lastScoreUpdate = millis()
    }
}

function showScore() {
    // Score display in top-right
    let scoreColor = color(0, 255, 0) // Default green
    let totalCongestion = 0
    
    for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
            if (congestionGrid[i][j] > 2) {
                totalCongestion += congestionGrid[i][j] - 2
            }
        }
    }
    
    // Color based on performance
    if (totalCongestion > 10) {
        scoreColor = color(255, 0, 0) // Red for high congestion
    } else if (totalCongestion > 5) {
        scoreColor = color(255, 255, 0) // Yellow for medium congestion
    }
    
    fill(0, 0, 0, 150)
    noStroke()
    rect(width - 150, 10, 140, 30, 5)
    
    fill(scoreColor)
    textSize(16)
    textAlign(RIGHT)
    text('Score: ' + score, width - 20, 30)
    textAlign(LEFT) // Reset alignment
}

function showSelectionInfo(){
    if (height > INFO_PANEL_HEIGHT) {
        noStroke(); fill(255,255,255,150)
        rect(0, height - INFO_PANEL_HEIGHT, width, INFO_PANEL_HEIGHT)
        fill(0); textSize(14)
        text('Press keys 1-6 to choose road piece', 10, height - 45)
        text('Shift+click or right-click to rotate', 10, height - 30)
        text('Map expands every ' + EXPAND_SECONDS + 's and traffic increases', 10, height - 15)
        text('Selected: ' + selectedRoadType, 10, 15)
    }
}

function mousePressed(){
    const i=floor(mouseX/gridSize), j=floor(mouseY/gridSize)
    if(i<0||i>=cols||j<0||j>=rows) return
    
    // Handle rotation with right-click or Shift+left-click
    if ((mouseButton === RIGHT || (mouseButton === LEFT && keyIsDown(SHIFT))) && roadGrid[i][j]) {
        const now = millis()
        if (now - lastRotationTime > 200) {
            roadGrid[i][j].rotation = (roadGrid[i][j].rotation + 90) % 360
            roadGrid[i][j].connections = getConnections(roadGrid[i][j].type, roadGrid[i][j].rotation)
            lastRotationTime = now
        }
    } 
    // Handle placement with left-click (without shift)
    else if(mouseButton===LEFT && !keyIsDown(SHIFT) && !roadGrid[i][j]){
        roadGrid[i][j]=new RoadTile(i,j,selectedRoadType,0)
    }
}

function keyPressed(){
    if(key==='1')selectedRoadType='straight'
    if(key==='2')selectedRoadType='corner'
    if(key==='3')selectedRoadType='t_junction'
    if(key==='4')selectedRoadType='cross'
    if(key==='5')selectedRoadType='roundabout'
    if(key==='6')selectedRoadType='flyover'
}

// consider Godot 2D tilemap for further scaling
</script>
</body>
</html>